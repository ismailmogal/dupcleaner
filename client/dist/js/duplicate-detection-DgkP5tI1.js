var e=(e,t,n)=>new Promise((s,i)=>{var a=e=>{try{l(n.next(e))}catch(t){i(t)}},r=e=>{try{l(n.throw(e))}catch(t){i(t)}},l=e=>e.done?s(e.value):Promise.resolve(e.value).then(a,r);l((n=n.apply(e,t)).next())});class t{constructor(){this.duplicateGroups=[],this.progressCallback=null,this.cancelToken={cancelled:!1}}setProgressCallback(e){this.progressCallback=e}cancel(){this.cancelToken.cancelled=!0}updateProgress(e,t,n=""){this.progressCallback&&this.progressCallback(e,t,n)}findExactMatches(e){const t=new Map;let n=0;for(const s of e){if(this.cancelToken.cancelled)return[];const i=`${s.name||""}_${s.size||0}`;t.has(i)||t.set(i,[]),t.get(i).push(s),n++,n%5e3==0&&this.updateProgress(n,e.length,"Finding exact matches...")}return Array.from(t.values()).filter(e=>e.length>1)}findSimilarNames(e,t=.8){const n=[],s=new Set,i=new Map,a=new Map;for(const l of e){if(this.cancelToken.cancelled)return[];const e=l.name||"",t=this.getFileExtension(e),n=e.length;i.has(t)||i.set(t,[]),i.get(t).push(l),a.has(n)||a.set(n,[]),a.get(n).push(l)}const r=Math.ceil(e.length/100);for(let l=0;l<r;l++){if(this.cancelToken.cancelled)return[];const h=100*l,c=Math.min(h+100,e.length),o=e.slice(h,c);for(const e of o){if(s.has(e.id))continue;const r=e.name||"",l=this.getFileExtension(r),h=r.length,c=[e];s.add(e.id);const o=i.get(l)||[],f=a.get(h)||[],u=o.length<=f.length?o:f,g=Math.floor(.5*h),d=Math.ceil(1.5*h);for(const n of u){if(this.cancelToken.cancelled)return[];if(s.has(n.id)||n.id===e.id)continue;const i=n.name||"",a=i.length;if(!(a<g||a>d)&&this.quickSimilarityCheck(r,i,t)){this.calculateNameSimilarityOptimized(r,i)>=t&&(c.push(n),s.add(n.id))}}c.length>1&&n.push(c)}this.updateProgress(l+1,r,"Finding similar names...")}return n}quickSimilarityCheck(e,t,n){if(e===t)return!0;const s=e.length,i=t.length,a=Math.max(s,i),r=Math.min(s,i);if(r/a<.5)return!1;let l=0;const h=Math.min(4,r);for(let c=0;c<h&&e[c]===t[c];c++)l++;return l>=Math.min(2,.3*r)}findSizeMatches(e,t=.01){const n=[],s=new Map;for(const r of e){if(this.cancelToken.cancelled)return[];const e=r.size||0;if(0===e)continue;const t=Math.floor(10*Math.log10(e));s.has(t)||s.set(t,[]),s.get(t).push(r)}let i=0;const a=s.size;for(const[r,l]of s){if(this.cancelToken.cancelled)return[];if(!(l.length<2)){l.sort((e,t)=>(e.size||0)-(t.size||0));for(let e=0;e<l.length;e++){const s=l[e],i=s.size||0,a=[s];for(let n=e+1;n<l.length;n++){const e=l[n],s=e.size||0,r=Math.min(i,s);if(!((Math.max(i,s)-r)/r<=t))break;a.push(e)}if(a.length>1){n.push(a);for(let t=a.length-1;t>0;t--){const n=l.indexOf(a[t]);n>e&&l.splice(n,1)}}}i++,i%10==0&&this.updateProgress(i,a,"Finding size matches...")}}return n}findHashMatches(e){var t,n,s;const i=new Map;let a=0;for(const r of e){if(this.cancelToken.cancelled)return[];let l=null;(null==(n=null==(t=r.file)?void 0:t.hashes)?void 0:n.sha1Hash)?l=r.file.hashes.sha1Hash:(null==(s=r.hashes)?void 0:s.sha1Hash)?l=r.hashes.sha1Hash:r.sha1Hash&&(l=r.sha1Hash),l&&(i.has(l)||i.set(l,[]),i.get(l).push(r)),a++,a%5e3==0&&this.updateProgress(a,e.length,"Finding hash matches...")}return Array.from(i.values()).filter(e=>e.length>1)}calculateNameSimilarityOptimized(e,t){if(e===t)return 1;if(0===e.length||0===t.length)return 0;const n=e.length,s=t.length,i=Math.max(n,s);return Math.min(n,s)/i<.5?0:i<50?this.levenshteinDistanceOptimized(e,t):this.jaroWinklerDistance(e,t)}levenshteinDistanceOptimized(e,t){const n=e.length,s=t.length;if(0===n)return s;if(0===s)return n;let i=new Array(s+1),a=new Array(s+1);for(let h=0;h<=s;h++)i[h]=h;for(let h=1;h<=n;h++){a[0]=h;for(let n=1;n<=s;n++){const s=e[h-1]===t[n-1]?0:1;a[n]=Math.min(a[n-1]+1,i[n]+1,i[n-1]+s)}[i,a]=[a,i]}const r=i[s],l=Math.max(n,s);return(l-r)/l}jaroWinklerDistance(e,t){if(e===t)return 1;const n=e.length,s=t.length;if(0===n||0===s)return 0;const i=Math.floor(Math.max(n,s)/2)-1;if(i<0)return 0;const a=new Array(n).fill(!1),r=new Array(s).fill(!1);let l=0,h=0;for(let g=0;g<n;g++){const n=Math.max(0,g-i),h=Math.min(s,g+i+1);for(let s=n;s<h;s++)if(!r[s]&&e[g]===t[s]){a[g]=!0,r[s]=!0,l++;break}}if(0===l)return 0;let c=0;for(let g=0;g<n;g++)if(a[g]){for(;!r[c];)c++;e[g]!==t[c]&&h++,c++}const o=(l/n+l/s+(l-h/2)/l)/3;let f=0;const u=Math.min(4,Math.min(n,s));for(let g=0;g<u&&e[g]===t[g];g++)f++;return o+.1*f*(1-o)}getFileExtension(e){const t=e.lastIndexOf(".");return t>0?e.substring(t+1).toLowerCase():""}formatFileSize(e){if(0===e)return"0 Bytes";const t=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,t)).toFixed(2))+" "+["Bytes","KB","MB","GB"][t]}findAllDuplicates(t){return e(this,arguments,function*(t,n=["exact","similar","size"],s=5e3){if(!Array.isArray(t)||0===t.length)return[];Array.isArray(n)&&0!==n.length||(n=["exact","similar","size"]),this.cancelToken.cancelled=!1;const i=[];t.length,this.updateProgress(0,n.length,"Starting duplicate detection...");const a=n.map((s,i)=>e(this,null,function*(){if(this.cancelToken.cancelled)return[];this.updateProgress(i,n.length,`Processing ${s} detection...`);let e=[];try{switch(s){case"exact":e=this.findExactMatches(t);break;case"similar":e=this.findSimilarNames(t);break;case"size":e=this.findSizeMatches(t);break;case"hash":e=this.findHashMatches(t)}}catch(a){return[]}return e.filter(e=>Array.isArray(e)&&e.length>1&&e.every(e=>e&&"object"==typeof e)).map(e=>({method:s,files:e,totalSize:e.reduce((e,t)=>e+(t.size||0),0)}))}));return(yield Promise.all(a)).forEach(e=>{i.push(...e)}),this.updateProgress(n.length,n.length,"Duplicate detection completed"),i})}findDuplicates(e,t=["exact","similar","size"]){return this.findAllDuplicates(e,t)}}export{t as D};
